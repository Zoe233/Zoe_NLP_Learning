第6章 学习分类文本
6.1 有监督分类
    性别鉴定
    选择正确的特征
    文档分类
    探索上下文语境
    序列分类
    其他序列分类方法
6.2 有监督分类的更多例子
    句子分割
    识别对话行为类型
    识别文字蕴含
    拓展到大型数据集
6.3 评估
    测试集
    准确度
    精确度和召回率
    混淆矩阵
    交叉验证
6.4 决策树
    熵和信息增益
6.5 朴素贝叶斯分类器
    潜在概率模型
    零计数和平滑
    非二元特征
    独立的朴素
    双重计数的原因
6.6 最大熵分类器
    最大熵模型
    熵的最大化
    生成式分类器对比条件式分类器
6.7 为语言模式建模
    模型告诉我们什么？


    模式识别是自然语言处理的一个核心部分。

    以-ed结尾的词往往是过去时态动词；
    频繁使用will时新闻文本的暗示...

    这些可观察到的模式 -- 词的结构和词频 -- 恰好与特定方面的含义关联，如：时态和主题。

    本章的目标是要回答下列问题：
        1. 我们怎样才能识别语言数据中能明显用于对其分类的特征？
        2. 我们怎样才能构建语言模型，用于自动执行语言处理任务？
        3. 从这些模型中我们可以学到哪些关于语言的知识？
    一路上，我们将研究一些重要的机器学习技术，包括决策树、朴素贝叶斯分类器和最大熵分类。

6.1 有监督分类

    分类是为给定的输入选择正确的类标签的任务。
    在基本的分类任务中，每个输入被认为是与所有其他输入隔离的， 并且标签集是预先定义的。

    例子：
        垃圾邮件判定；
        新闻主题分类；
        决定词bank给定的出现是用来指河的坡岸、一个金融机构、向一边倾斜的动作还是在金融机构里的存储行为。

    基本的分类任务有很多有序的变种。
    例如：在多类分类中，每个实例可以分配多个标签；
         在开放性分类中，标签集事先没有定义的；
         在序列分类中，一个输入链表作为一个整体分类。

    如果分类的建立基于包含每个输入的正确标签的训练语料，被称为 有监督分类。
    有监督分类使用的框架图。
6.1.1 性别鉴定
    似然比，可以用于比较不同特征-结果关系。

    在处理大型语料时，构建一个包含每一个实例的特征的单独的链表会使用大量的内存。
    在这种情况下，使用函数nltk.classify.apply_features，返回一个对象。
        >>> def gender_features(word):
        ...     return {'last_letter':word[-1]}

        >>> from nltk.classify import apply_features
        >>> train_set = apply_features(gender_features, names[500:])
        >>> test_set = apply_features(gender_features, names[:500])

6.1.2 选择正确的特征
    选择相关的特征，并决定如何为一个学习方法编码它们，这对学习方法提取一个好的模型可以产生巨大的影响。
    建立一个分类器的很多有趣的工作之一是找出哪些特征可能是相关的，以及我们如何能够表示它们。
    虽然使用相当简单而明显的特征集往往可以得到像样的性能，但是使用精心构建的基于对当前任务的透彻理解的特征，通常会显著提高收益。

    典型地，特征提取通过反复试验和错误的过程建立的，由哪些信息是与问题相关的直觉指引的。
    它通常以"厨房水槽"的方法开始，包括你能想到的所有特征，然后检查哪些特征是实际有用的。

    太多特征-- 一般化性能差，高度依赖训练数据特征--过拟合。

    一旦初始特征集被选定，完善特征集的一个非常有成效的方法是 错误分析。
    选择一个开发集，包含用于创建模型的语料数据，将开发集分为 训练集 和 测试集。
    使用测试集，检查个别错误案例，分析，尝试确定什么额外信息能使其能够做出正确的决定，调整特征集。
    迭代验证这个过程。

6.1.3 文档分类
6.1.4 探索上下文语境
6.1.5 序列分类
6.1.6 其他序列分类方法


6.2 有监督分类的更多例子
    句子分割
    识别对话行为类型
    识别文字蕴含
    拓展到大型数据集
6.3 评估
    测试集
    准确度
    精确度和召回率
    混淆矩阵
    交叉验证