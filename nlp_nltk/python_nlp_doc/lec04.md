第4章 编写结构化程序
4.7 算法设计
    递归
    权衡空间与时间
    动态规划

4.7 算法设计
    解决算法问题的一个重要部分是为手头的问题 选择或改造 一个合适的算法。

    有时会有几种选择，能否选择最好的一个取决于对每个选择随数据增长如何执行的知识。

    最有名的策略被称为 -- 分而治之。
        我们解决一个大小为n的问题通过将其分成两个大小为n/2的问题，解决这些问题，组成它们的结果称为原问题的结果。

        例如：
            假设我们有一堆卡片，每张卡片上写了一个词。
            我们可以排序这一堆卡片，通过将它分成两半分别给另外两个人来排序（他们又可以做同样的事情）。
            然后，得到两个排序好的卡片堆，将它们并成一个单一的排序堆就是一项容易的任务了。

        通过分而治之排序：对一个数组排序，我们将其分成两半并对每一半进行排序（递归）；
            将每个排好序的一半合并成一个完整的链表（再次递归）-- 这个算法被称为"归并排序"。


        另一个例子是在词典中查找一个词的过程。
        我们打开在书的中部的一个地方，比较我们的词与当前页面的词。
        如果它在词典中的词前面，我们就在词典的前一半重复上面的过程；
        如果它在后面，我们就使用词典的后一半。
        这种搜索方法被称为 二分查找 ，因为它的每一步都将问题分裂成一半。


        算法设计的另一种方法，我们解决问题通过将它转化为一个我们已经知道如何解决的问题的一个实例。
        例如：
            为了检测链表中的重复项，我们可以 预排序 这个链表，然后通过一次扫描检查是否有相邻的两个元素是相同的。



4.7.1 递归
    上面的关于排序和搜索的例子有一个引人注目的特征：
        解决一个大小为n个问题，可以将其分成两半，然后处理一个或多个大小为n/2的问题。
        一种一般的方式来实现这种方法是使用递归。


        例1：lec04_recursion

        我们可以用递归处理深层嵌套的对象。
        例2：
            WordNet的上位词层次。
            让我们计数给定同义词集s为根的上位词层次的大小。
            我们会找到s的每个下位词的大小，然后将它们加到一起（我们也将加1表示同义词集本身）。

        例3：
            字母查找树 letter trie 一种可以用来索引词汇的数据结构，一次一个字母。



4.7.2 权衡空间与时间

    我们有时可以显著的加快程序的执行，通过建设一个辅助的数据结构，例如：索引。

    例子：一个简单的全文检索系统 lec04_balance


4.7.3 动态规划
    动态规划Dynamic programming 是一种自然语言处理中被广泛使用的算法设计的一般方法。

    "programming"一词的用法与你可能想到的感觉不同，是规划或调度的意思。
    动态规划用于解决包含多个重叠的子问题的问题。
    不是反复计算这些子问题，而是简单的将它们的计算你结果存储在一个查找表中。

    我们将介绍动态规划，但在一个相当不同的背景：句法分析下介绍。

    例子：lec04_dynamic_programming


